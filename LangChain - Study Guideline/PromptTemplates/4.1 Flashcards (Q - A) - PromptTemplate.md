
---
# **ðŸ“˜ 45 Flashcard Questions**

1. **What is a PromptTemplate?**
2. **Why use PromptTemplates instead of writing prompts manually?**
3. **What are template variables?**
4. **What is the difference between a static prompt and a PromptTemplate?**
5. **What happens if you forget a required variable?**
6. **How do you define a PromptTemplate in LangChain?**
7. **What must always match between template and runtime?**
8. **What is a multi-input template?**
9. **What syntax is used to denote variables?**
10. **Can you nest templates inside templates?**
11. **Why validate prompt variables before injecting them?**
12. **What is the benefit of drafting prompts in modular blocks?**
13. **What is progressive prompting?**
14. **Why specify output format explicitly?**
15. **Whatâ€™s the risk of using vague instructions?**
16. **What is a PromptTemplate chain?**
17. **Which method is commonly used for chaining templates in LangChain?**
18. **What does a typical 4-stage PromptTemplate pipeline include?**
19. **What is the advantage of using pipelines over one large prompt?**
20. **Can you conditionally skip a stage in a PromptTemplate pipeline?**
21. **What is synthetic input testing?**
22. **Why include â€œtough constraintsâ€ in template instructions?**
23. **Whatâ€™s the quickest way to debug a failing PromptTemplate?**
24. **What should you test when creating a new template?**
25. **Why test templates with edge cases like empty or huge inputs?**
26. **What is a â€œmacro templateâ€?**
27. **What makes a PromptTemplate predictable?**
28. **What is a â€œslot-fillingâ€ approach in PromptTemplates?**
29. **What is the â€œpersona injectionâ€ pattern?**
30. **How do you handle variable-length lists in templates?**
31. **Why avoid ambiguous instructions like â€œexpand if neededâ€?**
32. **Why specify output format upfront?**
33. **Why set explicit length constraints?**
34. **What is prompt injection, and how do templates help?**
35. **Why use versioning for production PromptTemplates?**
36. **What is a conditional template?**
37. **How do PromptTemplates help in RAG systems?**
38. **What is template â€œfew-shot injectionâ€?**
39. **How can templates improve multi-language support?**
40. **What is a â€œtemplate libraryâ€ or â€œprompt registryâ€?**
41. **When should you split one large template into smaller ones?**
42. **Whatâ€™s the difference between a template variable and a template constant?**
43. **Why document your templates with comments or metadata?**
44. **What is the DRY principle in PromptTemplating?**
45. **How do you measure PromptTemplate quality?**

---

# **ðŸ”¹ Block 1 â€” Core Concepts**

### **1) What is a PromptTemplate?**

A **PromptTemplate** is a reusable prompt blueprint with placeholders (variables) that are filled dynamically at runtime to generate consistent, context-specific prompts.

**|> Why It Matters**

* Predictable structure across tasks
* Less rewriting, fewer mistakes
* Scalable + modular
* Supports dynamic inputs (topic, tone, style)

**|> Example in Action**

```
Template: "Explain {topic} in a {tone} tone."
Input: topic = "machine learning", tone = "simple"
Output: "Explain machine learning in a simple tone."
```

**|> Memory Hook â€”** Blueprint + Variables = Predictable Prompts
**|> In simple words â€”** A reusable prompt where you **just fill in the blanks**.

---

### **2) Why use PromptTemplates instead of writing prompts manually?**

They enforce consistency, reduce errors, increase reusability, and allow dynamic injection of values without writing the whole prompt again.

**|> Why It Matters**

* Faster workflows
* Fewer copy-paste mistakes
* Works well in automation
* Ensures uniform outputs

**|> Example in Action**

```
Generic Template: "Write a {length}-word overview of {topic}."

You reuse this template for:
- topic = "blockchain", length = 100
- topic = "climate change", length = 150
```

**|> Memory Hook â€”** One template â†’ infinite consistent outputs
**|> In simple words â€”** You donâ€™t rewrite; you reuse.

---

### **3) What are template variables?**

Variables are placeholders like `{topic}` or `{tone}` that get replaced with real values at runtime.

**|> Why It Matters**

* Makes prompts dynamic
* Reduces duplication
* Ensures structure stays intact
* Allows flexible runtime control

**|> Example in Action**

```
"Write a {style} intro about {subject}."
style = "formal"
subject = "neural networks"
```

**|> Memory Hook â€”** Variables = flexible slots
**|> In simple words â€”** The â€œblank spacesâ€ you fill.

---

### **4) Static prompt vs PromptTemplate**

A static prompt never changes. A PromptTemplate has variables and adapts automatically based on inputs.

**|> Why It Matters**

* Static = rigid
* Template = reusable
* Dynamic prompts = scalable systems
* Works better in pipelines & automation

**|> Example in Action**

```
Static: "Write about AI in a formal tone."
Template: "Write about {topic} in a {tone} tone."
```

**|> Memory Hook â€”** Static = fixed; Template = flexible
**|> In simple words â€”** One is frozen; one is adaptable.

---

### **5) What if a required variable is missing?**

The template fails â€” either an error or a broken final prompt with `{variable}` still visible.

**|> Why It Matters**

* Prevents malformed prompts
* Helps catch bugs early
* Critical in production workflows
* Ensures reliability

**|> Example in Action**

```
Template: "Summarize {text}."
Input passed: (nothing)

Result â†’ Error or "Summarize {text}."
```

**|> Memory Hook â€”** Missing variable = broken prompt
**|> In simple words â€”** Forgetting inputs breaks everything.



# **ðŸ”¹ Block 2 â€” Syntax & Structure 
_Crisp â€¢ High-Yield â€¢ Template-Aligned_

---

### **6) How do you define a PromptTemplate in LangChain (Python)?**

Use `PromptTemplate.from_template("Write about {topic} in {tone} tone")`. Curly braces `{}` mark variables.

**|> Why It Matters**
- Clear variable mapping
- Works with chains & LLMs
- Prevents mismatched inputs
- Standardized structure

**|> Example in Action**

```
tmpl = PromptTemplate.from_template("Explain {idea} to a {audience} reader.")

tmpl.format(idea="quantum computing", audience="beginner")
```

**|> Memory Hook â€”** `{}` = variable slots in LangChain  
**|> In simple words â€”** Define once â†’ reuse everywhere.

---

### **7) What must match between template and runtime?**

Variable names must match exactly: `{topic}` must receive `topic="value"`.

**|> Why It Matters**
- Avoids missing-variable errors
- Ensures clean prompt rendering
- Essential for pipelines
- Prevents malformed outputs

**|> Example in Action**

```
Template: "Describe {item}"
Wrong: format(thing="AI") âŒ
Correct: format(item="AI") âœ”
```

**|> Memory Hook â€”** Matching names = zero errors  
**|> In simple words â€”** Same name in template and input.

---

### **8) What is a multi-input template?**

A template requiring multiple variables: `{topic}`, `{tone}`, `{length}`, etc.

**|> Why It Matters**
- Richer prompts
- More control
- Better for structured tasks 
- Supports complex workflows 

**|> Example in Action**

```
"Write a {length}-word {tone} intro about {topic}."
```

**|> Memory Hook â€”** More slots = more control  
**|> In simple words â€”** Template with many blanks.

---

### **9) What syntax is used for variables in templating systems?**

Most systems use `{variable}`, while Jinja2/Mustache use `{{variable}}`.

**|> Why It Matters**
- Prevents syntax confusion
- Enables correct rendering
- Important when switching frameworks
- Avoids literal text leakage

**|> Example in Action**

```
LangChain: {topic}
Jinja2: {{ topic }}
```

**|> Memory Hook â€”** One brace vs two braces  
**|> In simple words â€”** Different systems = different brackets.

---

### **10) Can you nest templates inside templates?**

Yes â€” known as â€œtemplate composition,â€ where one template feeds another.

**|> Why It Matters**
- Enables multi-stage pipelines
- Helps reuse formatting logic
- Keeps prompts modular
- Powers advanced RAG flows

**|> Example in Action**

```
summary = SummaryTemplate(...)
rewrite = RewriteTemplate(...)

final = summary(text) â†’ rewrite(summary_output)
```

**|> Memory Hook â€”** Output of one â†’ input to next  
**|> In simple words â€”** Templates stacked like LEGO.

---

# **ðŸ”¹ Block 3 â€” Good Practices**

_Design Principles â€¢ Production Thinking â€¢ Extremely Useful_

---

### **11) Why validate variables before injecting them?**

To avoid broken prompts, missing content, or unsafe injections.

**|> Why It Matters**

- Prevents runtime failures
- Ensures clean formatting
- Blocks harmful input
- Critical for automation safety

**|> Example in Action**

```
if not topic: raise ValueError("Missing topic")
```

**|> Memory Hook â€”** Validate â†’ safe prompts  
**|> In simple words â€”** Check inputs before use.

---

### **12) Why draft prompts in modular blocks?**

Sections make prompts easier to debug, reuse, and refine.

**|> Why It Matters**

- Clear structure
- Less hallucination
- High reusability
- Faster maintenance

**|> Example in Action**

```
[Goal]  
[Context]  
[Instructions]  
[Output Format]
```

**|> Memory Hook â€”** Blocks = clarity  
**|> In simple words â€”** Break big into small.

---

### **13) What is â€œprogressive promptingâ€?**

A multi-stage prompt pipeline: cleanup â†’ structure â†’ refine â†’ finalize.

**|> Why It Matters**
- Higher-quality outputs
- Control at each step
- Prevents compounding errors
- Perfect for production systems

**|> Example in Action**

```
raw â†’ cleaned â†’ structured â†’ polished â†’ final
```

**|> Memory Hook â€”** Step-by-step improves accuracy  
**|> In simple words â€”** Refine in stages.

---

### **14) Why specify output format explicitly?**

For predictable, parseable, automation-friendly outputs.

**|> Why It Matters**
- Easier validation
- Zero ambiguity 
- Works with APIs & databases
- Reduces hallucination

**|> Example in Action**

```
"Output as JSON: { 'title': ..., 'summary': ... }"
```

**|> Memory Hook â€”** Specify format = predictable output  
**|> In simple words â€”** Tell model the exact shape.

---

### **15) Whatâ€™s the risk of vague instructions?**

The model may over-generate, hallucinate, or vary results unpredictably.

**|> Why It Matters**
- Unstable response patterns
- Hard to evaluate
- Fails in automation
- Inconsistent quality


**|> Example in Action**

```
Bad: "Expand if needed."
Better: "Write exactly 3 bullet points."
```

**|> Memory Hook â€”** Vague prompt â†’ vague output  
**|> In simple words â€”** Unclear rules = messy results.

# **ðŸ”¹ Block 4 â€” Chaining & Pipelines

_Multi-Step Workflows â€¢ Refinement â€¢ Systems Thinking_

---

### **16) What is a PromptTemplate chain?**

A chain connects multiple templates in sequence so each templateâ€™s output becomes the next templateâ€™s input.

**|> Why It Matters**
- Enables multi-step reasoning
- Supports refinement workflows
- Perfect for document pipelines
- Modular + easy to debug

**|> Example in Action**

```
Template 1 â†’ cleans text  
Template 2 â†’ structures it  
Template 3 â†’ rewrites it  
Template 4 â†’ formats the output
```

**|> Memory Hook â€”** One step feeds the next  
**|> In simple words â€”** Templates linked like a workflow.

---

### **17) What method is used for chaining in LangChain?**

Use `.pipe()` or the `|` operator to pass output from one template to the next.

**|> Why It Matters**
- Clean syntax
- Reduces boilerplate
- Works like Unix pipes
- Ideal for multi-stage pipelines

**|> Example in Action**

```
template1 | template2 | template3
```

**|> Memory Hook â€”** Pipes = flow control  
**|> In simple words â€”** Chain templates like commands.

---

### **18) What does a typical 4-stage template pipeline include?**

1. Cleanup â†’ 2) Structure â†’ 3) Refine â†’ 4) Format.


**|> Why It Matters**

- Predictable quality
- Step-by-step transformation
- Better control
- Easier error isolation

**|> Example in Action**

```
(raw text) 
â†’ normalize 
â†’ outline 
â†’ rewrite 
â†’ final output
```

**|> Memory Hook â€”** 4 Sâ€™s: Sanitize, Structure, Sharpen, Shape  
**|> In simple words â€”** Improve it layer by layer.

---

### **19) Why use pipelines instead of one giant prompt?**

Pipelines are easier to debug, test, and reuse. Each step has a single purpose.

**|> Why It Matters**

- Modular
- Stable outputs
- Easier validation
- More scalable

**|> Example in Action**

```
Instead of 1 complex prompt:
Use 4 small ones doing 1 job each.
```

**|> Memory Hook â€”** One job per step  
**|> In simple words â€”** Small prompts beat big prompts.

---

### **20) Can you skip a stage in a pipeline?**

Yes â€” use conditional logic to include or bypass specific steps.

**|> Why It Matters**

- Adaptive workflows
- Handles different content types
- Optimizes runtime
- More flexible processing

**|> Example in Action**

```
if short_text: skip "cleanup"
else: run full pipeline
```

**|> Memory Hook â€”** Conditions = smart routing  
**|> In simple words â€”** Skip steps when not needed.

---

# **ðŸ”¹ Block 5 â€” Debugging & Testing**

_Quality Assurance â€¢ Stability â€¢ Practical Reliability_

---

### **21) What is synthetic input testing?**

Feeding randomized or extreme inputs to ensure the template doesnâ€™t break.

**|> Why It Matters**

- Catches edge-case failures
- Prevents crashes
- Ensures robustness
- Essential for production

**|> Example in Action**

```
Inputs:
- ""
- "@#$%^&*"
- 5000-word text
```

**|> Memory Hook â€”** Stress-test the template  
**|> In simple words â€”** Try to break it first.

---

### **22) Why include â€œtough constraintsâ€?**

Constraints like â€œexactly 3 bulletsâ€ produce predictable, testable outputs.

**|> Why It Matters**

- Reduces variability
- Prevents runaway generation
- Easier automatic validation
- More stable outputs

**|> Example in Action**

```
"List exactly 3 ideas:"
```

**|> Memory Hook â€”** Tight rules = tight outputs  
**|> In simple words â€”** Be strict to stay consistent.

---

### **23) Quickest way to debug a failing template?**

Print the final rendered prompt after variables are injected.

**|> Why It Matters**
- Reveals missing variables
- Shows formatting issues
- Debugs whitespace + structure
- Fastest diagnosis method

**|> Example in Action**

```
print(template.format(topic="AI"))
```

**|> Memory Hook â€”** Inspect before sending  
**|> In simple words â€”** Check the final prompt first.

---

### **24) What should you test in new templates?**

Test empty inputs, long inputs, special characters, missing variables, and multiple valid formats.

**|> Why It Matters**

- Ensures technical stability
- Prevents edge-case failures
- Supports wide input variety
- Essential for real-world use

**|> Example in Action**

```
"", long_text, emoji_text, null inputs
```

**|> Memory Hook â€”** Test the extremes  
**|> In simple words â€”** Try bad inputs on purpose.

---

### **25) Why test with edge cases like empty or 10,000-word inputs?**

To find breaking points, performance issues, and ensure graceful degradation.

**|> Why It Matters**
- Avoids catastrophic failures
- Reveals token issues
- Ensures scalability
- Guarantees production reliability

**|> Example in Action**

```
""
vs
a 10,000-word document
```

**|> Memory Hook â€”** Edge cases expose weaknesses  
**|> In simple words â€”** Test the impossible.

# **ðŸ”¹ Block 6 â€” Patterns & Workflows**

_Advanced Structures â€¢ Reusability â€¢ Prompt Architecture_

---

### **26) What is a â€œmacro templateâ€?**

A macro template is a master prompt that orchestrates multiple sub-templates and controls their flow.

**|> Why It Matters**
- Centralized logic
- Reduces duplication
- Manages multi-step tasks
- Great for large workflows

**|> Example in Action**

```
Macro:
- Call Template_A
- Call Template_B
- Combine outputs
```

**|> Memory Hook â€”** One big controller template  
**|> In simple words â€”** A â€œboss promptâ€ managing smaller prompts.

---

### **27) What makes a PromptTemplate predictable?**

Clear sections, explicit formats, bounded lengths, and consistent variable naming.

**|> Why It Matters**
- Stable outputs
- Easier automation
- Less hallucination
- Higher reliability

**|> Example in Action**

```
[Role]  
[Task]  
[Format]  
[Constraints]
```

**|> Memory Hook â€”** Predictable = structured + bounded  
**|> In simple words â€”** Make every output look the same.

---

### **28) What is a â€œslot-fillingâ€ approach?**

A structure with predefined slots where only variable content changes.

**|> Why It Matters**
- Template stays uniform
- Variables plug in cleanly
- Perfect for forms & reports
- Highly scalable

**|> Example in Action**

```
Title: {title}
Summary: {summary}
Points:
- {p1}
- {p2}
```

**|> Memory Hook â€”** Slots = fixed boxes  
**|> In simple words â€”** Like filling a form.

---

### **29) What is the â€œpersona injectionâ€ pattern?**

Pre-setting the modelâ€™s role or expertise before giving instructions.

**|> Why It Matters**
- Controls tone & domain
- Reduces ambiguity
- Improves accuracy
- Ensures expertise style

**|> Example in Action**

```
"You are a cybersecurity expert. Analyze the following logs:"
```

**|> Memory Hook â€”** Persona first â†’ task next  
**|> In simple words â€”** Tell the model â€œwho it is.â€

---

### **30) How do you handle variable-length lists?**

Use loops in engines like Jinja2 or build the list dynamically in code.

**|> Why It Matters**
- Handles unknown item counts
- Prevents template failures
- Flexible list generation
- Works for dynamic datasets

**|> Example in Action**

```
{% for item in items %}
- {{ item }}
{% endfor %}
```

**|> Memory Hook â€”** Loop = flexible list output  
**|> In simple words â€”** Generate bullets on the fly.

---

# **ðŸ”¹ Block 7 â€” Safety & Stability**

_Production Reliability â€¢ Security â€¢ Consistency_

---

### **31) Why avoid ambiguous instructions?**

Ambiguous tasks create unpredictable, inconsistent outputs.

**|> Why It Matters**
- Prevents hallucinations
- Cuts token waste
- Improves reliability
- Ensures testable outputs


**|> Example in Action**

```
Bad: "Write more details if needed."
Better: "Write exactly 4 sentences."
```

**|> Memory Hook â€”** Ambiguity = chaos  
**|> In simple words â€”** Be specific or get messy results.

---

### **32) Why specify output format upfront?**

Clear formatting ensures reliable parsing and integration with systems.

**|> Why It Matters**
- Machine-readable
- Fewer post-processing errors
- Ideal for APIs & databases
- Eliminates structure ambiguity

**|> Example in Action**

```
"Return JSON with keys: title, insights, actions"
```

**|> Memory Hook â€”** Format first = stable output  
**|> In simple words â€”** Tell the model the shape before content.

---

### **33) Why set explicit length constraints?**

Length limits control output size, cost, and consistency.

**|> Why It Matters**
- Predictable boundaries
- Prevents over-generation
- Fits UI/UX requirements
- Easier evaluation

**|> Example in Action**

```
"Max 120 words." 
"Exactly 5 lines."
```

**|> Memory Hook â€”** Length rules = safe boundaries  
**|> In simple words â€”** Tell it how long.

---

### **34) What is prompt injection and how do templates help?**

Prompt injection occurs when user inputs try to override instructions. Templates enforce structure and sanity checks.

**|> Why It Matters**
- Protects system behavior
- Prevents malicious overrides
- Ensures instruction separation
- Critical for public applications

**|> Example in Action**

```
User Input: "Ignore previous instructions and..."
Template sanitization: escapes or blocks it.
```

**|> Memory Hook â€”** Structure protects instructions  
**|> In simple words â€”** Clean inputs = safe outputs.

---

### **35) Why version your PromptTemplates?**

Versioning allows rollback, audits, experiments, and safer updates.

**|> Why It Matters**
- Track changes
- Compare performance
- A/B test improvements
- Maintain stability

**|> Example in Action**

```
template_v1  
template_v1.1  
template_v2
```

**|> Memory Hook â€”** Versions = control  
**|> In simple words â€”** Label your templates like code.

---

# **ðŸ”¹ Block 8 â€” Advanced Uses**

_RAG â€¢ Multilingual â€¢ Conditional Prompts â€¢ Few-Shot_

---

### **36) What is a conditional template?**

A template that changes structure based on input flags or parameters.

**|> Why It Matters**
- Adaptive behavior
- Multi-language support
- Context-aware formatting
- More intelligent workflows

**|> Example in Action**

```
if language == "es":
   use Spanish block
else:
   use English block
```

**|> Memory Hook â€”** Logic-driven templates  
**|> In simple words â€”** Template that behaves differently based on input.

---

### **37) How do PromptTemplates help in RAG systems?**

They structure retrieved documents + queries consistently to improve answer quality.

**|> Why It Matters**
- Reduces hallucinations
- Ensures proper context merging
- Improves grounding
- Supports reliable citations

**|> Example in Action**

```
"Using the context below, answer the query.
Context: {documents}
Query: {question}"
```

**|> Memory Hook â€”** RAG = retrieval â†’ template â†’ answer  
**|> In simple words â€”** Templates organize retrieved facts.

---

### **38) What is â€œfew-shot injectionâ€?**

Embedding example input-output pairs inside the template to teach the desired pattern.

**|> Why It Matters**
- Better structure imitation
- More consistent reasoning
- Reduces errors
- Stronger in-context learning

**|> Example in Action**

```
Example:
Q: X  
A: Y  
---
Now answer:
Q: {user_q}
```

**|> Memory Hook â€”** Show examples â†’ get better output  
**|> In simple words â€”** Demonstrate the pattern first.

---

### **39) How do templates improve multi-language support?**

By separating fixed instructions from variable content, enabling easy localization.

**|> Why It Matters**
- Same structure across languages
- Better translation consistency
- Cultural flexibility
- Cleaner international workflows

**|> Example in Action**

```
"[In {language}] Summarize the following text: {text}"
```

**|> Memory Hook â€”** Structure stays; language changes  
**|> In simple words â€”** One template â†’ many languages.

---

### **40) What is a â€œtemplate libraryâ€ or registry?**

A repository where templates are stored, versioned, tagged, and reused.

**|> Why It Matters**
- Organization
- Collaboration
- Quality control
- Reusability across teams

**|> Example in Action**

```
/summaries  
/rag  
/reports  
/chatbots
```

**|> Memory Hook â€”** A library of reusable prompt parts  
**|> In simple words â€”** Store templates like code modules.
# **ðŸ”¹ Block 9 â€” Meta-Learning**

*Optimization â€¢ Maintainability â€¢ Long-Term Prompt Engineering Skills*

---

### **41) When should you split a large template into smaller ones?**

Split when a template becomes too long, serves multiple purposes, or needs independent testing/versioning.

**|> Why It Matters**

* Easier debugging
* Higher clarity
* Reusable components
* Better pipeline control

**|> Example in Action**

```
Too big: 300+ tokens  
Split into: cleanup, outline, rewrite, format
```

**|> Memory Hook â€”** Big â†’ break into blocks
**|> In simple words â€”** If itâ€™s heavy, divide it.

---

### **42) Template variable vs template constant**

Variables change on each run; constants remain fixed instructions.

**|> Why It Matters**

* Consistent baseline behavior
* Cleaner separating logic
* Easier maintenance
* Predictable structure

**|> Example in Action**

```
Constant: "Follow JSON format"
Variable: {topic}, {tone}
```

**|> Memory Hook â€”** Variables move; constants anchor
**|> In simple words â€”** One changes, one stays.

---

### **43) Why document templates with comments or metadata?**

It helps others understand intent, required variables, format expectations, and edge-cases.

**|> Why It Matters**

* Team clarity
* Faster onboarding
* Prevents misuse
* Easier maintenance

**|> Example in Action**

```
# Variables: topic, audience  
# Output: 3 bullets + summary
```

**|> Memory Hook â€”** Docs prevent confusion
**|> In simple words â€”** Leave notes for future you (and team).

---

### **44) What is the DRY principle in PromptTemplating?**

DRY = Donâ€™t Repeat Yourself. Reuse shared instructions instead of duplicating.

**|> Why It Matters**

* Less redundancy
* Fewer update mistakes
* Consistent behavior
* Cleaner template libraries

**|> Example in Action**

```
Shared block: â€œReturn JSON with keys: â€¦â€
Used in 12 templates â†’ stored once.
```

**|> Memory Hook â€”** DRY = reuse everything
**|> In simple words â€”** Donâ€™t write the same rules twice.

---

### **45) How do you measure PromptTemplate quality?**

Check consistency, edge-case performance, parsability, user satisfaction, and token efficiency.

**|> Why It Matters**

* Quantifies quality
* Guides optimization
* Supports A/B testing
* Ensures reliability

**|> Example in Action**

```
Metrics:
- Same input â†’ same output structure?
- Does JSON always parse?
- Fails gracefully under bad inputs?
```

**|> Memory Hook â€”** Quality = consistent, robust, parseable
**|> In simple words â€”** Good templates behave the same every time.
